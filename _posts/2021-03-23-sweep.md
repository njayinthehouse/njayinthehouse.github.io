---
layout: default
title: Sweeping Minesweeper to Make Mine
date: 2021-03-23
---

Sweeping Minesweeper to Make Mine
=================================

At the time of writing this article, Minesweeper lives 
[here](https://github.com/batfish/batfish/tree/2021-03-16-minesweeper/projects/minesweeper/src).
For my Networks course, my team and I have chosen to reimplement Minesweeper
by [Beckett et al. 2017](https://network-programming.org/papers/minesweeper.pdf)
in Scala. I'm going to provide a quick introduction to Minesweeper here, 
followed by some motivation towards the questions we hoped to answer in the 
course of this project. We made some progress towards those questions...
TODO Conclude this better

Background on Minesweeper
-------------------------

Minesweeper is a powerful network verification tool which is reported to 
achieve *high network design coverage* (i.e. support for various kinds of 
network topologies, routing protocols, etc.), *high data plane coverage* (i.e. 
can analyze a significant number (quantity?) of data planes), while remaining
scalable to real networks. The tool compiles user-specified network 
configuration files and network properties down to Z3 SMT constraints. 
The language of SMT constraints is enough to warrant two concrete departures 
from prior network testing literature:
(1) Users could reason about graphs instead of just paths.
(2) Users could *combinationally search* for messages, allowing them to 
    abstract over several possible tests and verify conditions for all of them 
    at once.

The authors also propose two very simple optimizations which apparently make a 
very big difference in performance: slicing (i.e. dead code elimination?) and
hoisting (i.e. common subexpression elimination?). It is was surprising to my
team and I that these optimizations make a difference, because we thought that 
Z3 would perform similar optimizations on its own. However, we didn't 
understand the finer implementation details of the paper at first, nor did we 
have a thorough understanding of how SMT solvers worked.

Code Sweep
----------

The code for Minesweeper lives in the Batfish repository. This is surprising,
because Batfish is another verification tool that Beckett et al. contrast
against Minesweeper. The codebase was larger than we expected for the concepts
given in the paper, and a very large chunk of it was simply interacting with
Batfish libraries. We found this suspicious, since, as given in the paper:

"""
Control plane analysistools such as Batfish [13] can find con-figuration errors proactively, before deploying potentially buggyconfigurations. Batfish takes the network configuration (i.e., its con-trol plane) and a specific environment (e.g., a link-failure scenario)as input and analyzes the resulting data plane. This ability allowsoperators to go beyond the current data plane and analyze futuredata planes that may arise under different environments. Still, eachrun of Batfish allows users to explore at most one data plane, andgiven the large number of possible environments, it is intractableto guarantee correctness for all possible data planes.
"""

We weren't sure how to begin grokking this code -- there was no documentation,
and comments were sparse and seemed personalised for the authors of the code.
We decided that the best way to go about it was to start naively rewriting the
code. The original implementation was in Java. Translating Java code to Scala
naively is a trivial task. Cleaning the code of antipatterns, on the other 
hand, is a much more daunting task. For instance, references being null is
*allowed* in Scala to allow interoperability with Java, but is considered an
antipattern and are replaced with Option types. However, we believed that this
route was the surest to completion of our re-implementation, and that would
allow us to spend more time considering further optimizations to the system

---

A few weeks later, we were still refactoring code and trying to makes sense of 
it. My lack of experience with large codebases was sorely showing, and we came
to two key realizations.

1. The bulk of the work of translating the code came from the dependencies on
   Batfish, which is a Java library and thus has no concern for Scala
   antipatterns.
2. Batfish data structures are being used, but no Batfish analyses.

We began to contemplate whether we should proceed with the translation as per
the course, or whether it was worth depending on Batfish at all. After all, 
learning to work with Batfish wasn't central to the problem that the 
Minesweeper paper was trying to solve, and we weren't as interested in that.

Pivot
-----

Our re-implementation was not going as planned. We were spending absurd amounts
of time, but were still struggling to the finer details in the paper to their
counterparts in the code. It was time for a heavy decision. 

1. Do we continue as par, with the knowledge that this route will lead to 
   completion, but maybe not in the required timeframe?
2. Or do attempt to implement Minesweeper from the principles laid out in 
   the paper?

We decided to try the latter for a bit to gain an understanding of the scale 
of such a project and whether we'd be able to implement it before the semester
was over. ;P

We were surprised at how straightforward it was to encode the ideas of the 
paper. We decided to pursue this route, and changed the story we were trying
to tell.

Question Formation
------------------

When we started this project, our goals were:

1. To reimplement Minesweeper in Scala
2. To record any potential benefits to choosing Scala over Java
3. To understand why the optimizations proposed in the paper were necessary, 
   and why Z3 wasn't "smart enough" to figure those out on its own.
4. To use this understanding to potentially experiment with new optimizations.

However, after the pivot, we were able to refine these goals further:

1. To implement Minesweeper as described in the original paper, with no
   dependency on Batfish.
2. To model Minesweeper explicitly using a compiler architecture, with an 
   intermediate language upon which we can perform optimizations.
3. To see if slicing and hoisting described in the original paper can be 
   performed using standard, off-the-shelf compiler optimizations.
4. To see if our intermediate made any additional optimizations apparent.

Minesweeper: A Compiler
-----------------------

The project got a lot more exciting now that we were making measurable 
progress. 

### Syntax Construction

We simultaneously developed two layers of our compiler:

1. A high-level language to express the network topology, configuration and
   expected properties.
   The network topology was represented as a graph, where the vertices could
   be routers or subnets. Control-plane configuration at every router was
   specified by a control plane record at every incoming and outgoing edge.
   We further supported import/export filters at every vertex. Data-plane
   configuration came in the form of access control lists (ACLs). 
   The kind of analyses that Minesweeper does quantifies over all data packets,
   but users can selectively refine this by concretely fixing the fields of our 
   universally quantified packet.

2. An intermediate representation, which was a thin wrapper on Z3 smtlib.
   This language
